<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>简易版白噪声任务 / Simple White Noise Task   </title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #f8f8f8;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        #setup, #task, #resultSection {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        label {
            display: block;
            margin-bottom: 10px;
        }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-top: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            margin: 10px 5px 0 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        button[disabled] {
            background: #cccccc;
            cursor: not-allowed;
        }
        #responseButtons button {
            width: 48%;
        }
        audio {
            width: 100%;
            margin-top: 15px;
        }
        #prompt {
            margin-top: 15px;
            font-style: italic;
        }

        /* Styles for trial selection buttons */
        .trialBtn {
            padding: 6px 12px;
            margin: 0 5px;
            border: 1px solid #007bff;
            background: #ffffff;
            color: #007bff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .trialBtn.selected {
            background: #007bff;
            color: #ffffff;
        }
    </style>
</head>
<body>

<h1>简易版白噪声任务 / Simple White Noise Task</h1>
<p style="text-align:center;">其中的语音都是中文普通话。/ All speech segments are Mandarin Chinese. Developed by Jackson. </p>

<div id="setup">
    <label>测试者姓名 (Tester Name): <input type="text" id="testerName"></label>
    <label>条件 (Condition): <input type="text" id="condition"></label>
    <div id="trialButtons" style="margin-bottom:10px;">
        <span>题量 (Number of trials): </span>
        <button type="button" id="btn30" class="trialBtn">30题 (每段只播放一遍) / 30 trials (one per segment)</button>
        <button type="button" id="btn60" class="trialBtn selected">60题 (每段播放两遍) / 60 trials (two per segment)</button>
    </div>
    <button id="startButton">开始测试 / Start Test</button>
</div>

<div id="task" style="display:none;">
    <p id="questionLabel"></p>
    <!-- The audio element plays automatically when a trial starts. Controls are omitted so users do not need to click play. -->
    <audio id="audioPlayer" preload="auto"></audio>
    <div id="responseButtons" style="display:none;">
        <button id="speechBtn" data-response="speech">听到中文语音 / Heard Chinese speech</button>
        <button id="noiseBtn" data-response="noise">只有白噪声 / Only white noise</button>
    </div>
    <p id="prompt">请倾听音频并选择您的答案。/ Please listen to the audio and choose your answer.</p>
</div>

<div id="resultSection" style="display:none;">
    <h2>结果 / Results</h2>
    <p id="resultSummary"></p>
    <h3>算法 / Algorithm</h3>
    <p id="algorithmDescription"></p>
</div>

<script>
// The list of audio files. Each object has the file path relative to this HTML file
// and a boolean indicating whether speech is present (signal) or not (noise).
// 请将所有音频文件放在与本文件同目录的 audio 文件夹中，并按照下面的命名方式命名。
const audioFiles = [];
// pure white noise: no speech
// 文件名格式示例：pure_noise (1).wav, pure_noise (2).wav 等
for (let i = 1; i <= 10; i++) {
    audioFiles.push({ file: `audio/pure_noise (${i}).wav`, isSignal: false });
}
// white noise with unclear Chinese speech
// The filenames for this category use a space and parentheses, e.g., "unclear_speech (1).wav".
for (let i = 1; i <= 10; i++) {
    audioFiles.push({ file: `audio/unclear_speech (${i}).wav`, isSignal: true });
}
// white noise with clear Chinese speech
// 文件名格式示例：clear_speech (1).wav, clear_speech (2).wav 等
for (let i = 1; i <= 10; i++) {
    audioFiles.push({ file: `audio/clear_speech (${i}).wav`, isSignal: true });
}

// Duplicate each audio file so that each appears twice
const fullList = [];
audioFiles.forEach(item => {
    fullList.push(Object.assign({}, item));
    fullList.push(Object.assign({}, item));
});

// Shuffle array in place (Fisher-Yates)
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

const testerNameInput = document.getElementById('testerName');
const conditionInput = document.getElementById('condition');
const startButton = document.getElementById('startButton');
const btn30 = document.getElementById('btn30');
const btn60 = document.getElementById('btn60');

// Default selected count is 60
let selectedCount = 60;

// Event handlers for trial selection buttons
btn30.addEventListener('click', () => {
    selectedCount = 30;
    btn30.classList.add('selected');
    btn60.classList.remove('selected');
});
btn60.addEventListener('click', () => {
    selectedCount = 60;
    btn60.classList.add('selected');
    btn30.classList.remove('selected');
});
const setupDiv = document.getElementById('setup');
const taskDiv = document.getElementById('task');
const questionLabel = document.getElementById('questionLabel');
const audioPlayer = document.getElementById('audioPlayer');
const responseButtonsDiv = document.getElementById('responseButtons');
const speechBtn = document.getElementById('speechBtn');
const noiseBtn = document.getElementById('noiseBtn');
const resultSection = document.getElementById('resultSection');
const resultSummary = document.getElementById('resultSummary');
const algorithmDescription = document.getElementById('algorithmDescription');

// Variables for task
let trialIndex = 0;
let trials = [];
let responses = [];

startButton.addEventListener('click', () => {
    const name = testerNameInput.value.trim();
    const cond = conditionInput.value.trim();
    if (!name) {
        alert('请输入测试者姓名。/ Please enter the tester\'s name.');
        return;
    }
    // Prepare trials based on selectedCount. When 30 is selected, each of the 30
    // unique audio files is played once; when 60 is selected, each is played twice.
    if (selectedCount === 30) {
        trials = audioFiles.slice();
    } else {
        trials = fullList.slice();
    }
    shuffle(trials);
    trialIndex = 0;
    responses = [];
    // hide setup and show task
    setupDiv.style.display = 'none';
    taskDiv.style.display = 'block';
    resultSection.style.display = 'none';
    nextTrial();
});

// Event listeners for response buttons
speechBtn.addEventListener('click', () => recordResponse(true));
noiseBtn.addEventListener('click', () => recordResponse(false));

function nextTrial() {
    if (trialIndex >= trials.length) {
        // End of task
        showResults();
        return;
    }
    // Update question label
    const currentNumber = trialIndex + 1;
    questionLabel.textContent = `第 ${currentNumber} / ${trials.length} 题  (Question ${currentNumber} of ${trials.length})`;
    // Set audio source (encode URI to handle spaces and special characters)
    const currentTrial = trials[trialIndex];
    audioPlayer.src = encodeURI(currentTrial.file);
    audioPlayer.load();
    // Disable response buttons until audio ends
    speechBtn.disabled = true;
    noiseBtn.disabled = true;
    responseButtonsDiv.style.display = 'none';
    // Play audio and enable responses after playback
    audioPlayer.onended = () => {
        responseButtonsDiv.style.display = 'block';
        speechBtn.disabled = false;
        noiseBtn.disabled = false;
    };
    audioPlayer.play().catch(err => {
        console.error('Audio playback error:', err);
        // In case of error, still allow responses
        responseButtonsDiv.style.display = 'block';
        speechBtn.disabled = false;
        noiseBtn.disabled = false;
    });
}

function recordResponse(responseIsSpeech) {
    // Record current trial result
    const trial = trials[trialIndex];
    responses.push({ isSignal: trial.isSignal, response: responseIsSpeech });
    trialIndex++;
    // Prepare for next trial
    nextTrial();
}

function showResults() {
    taskDiv.style.display = 'none';
    resultSection.style.display = 'block';
    // Calculate hits, misses, false alarms, correct rejections
    let hits = 0, misses = 0, falseAlarms = 0, correctRejections = 0;
    responses.forEach(r => {
        if (r.isSignal) {
            if (r.response) {
                hits++;
            } else {
                misses++;
            }
        } else {
            if (r.response) {
                falseAlarms++;
            } else {
                correctRejections++;
            }
        }
    });
    const nSignal = hits + misses;
    const nNoise = falseAlarms + correctRejections;
    // Compute rates
    let hitRate = nSignal > 0 ? hits / nSignal : 0;
    let falseAlarmRate = nNoise > 0 ? falseAlarms / nNoise : 0;
    // Apply correction when rates are 0 or 1 to avoid infinite z-scores
    function adjustRate(rate, N) {
        if (rate === 0) return 0.5 / N;
        if (rate === 1) return 1 - 0.5 / N;
        return rate;
    }
    const adjHitRate = adjustRate(hitRate, nSignal);
    const adjFARate = adjustRate(falseAlarmRate, nNoise);
    // Compute z-scores using inverse normal CDF
    const zHit = normInv(adjHitRate, 0, 1);
    const zFA = normInv(adjFARate, 0, 1);
    const dprime = zHit - zFA;
    const c = -0.5 * (zHit + zFA);
    // Prepare result text (rounded to 3 decimal places)
    const resultText =
        `FAR（错误报警率）/ False Alarm Rate: ${falseAlarmRate.toFixed(3)}\n` +
        `Sensitivity（d'）: ${dprime.toFixed(3)}\n` +
        `Response bias（c）: ${c.toFixed(3)}`;
    resultSummary.innerText = resultText;
    // Algorithm description (bilingual)
    const algoZh = `算法说明：FAR（错误报警率）是指噪声条件下选择“听到中文语音”的比例；Hit Rate（命中率）是指有语音条件下选择“听到中文语音”的比例。为避免比率为0或1导致的无限z值，我们在计算z值之前采用0.5/N的修正。敏感性（d'）= z(Hit Rate) - z(FAR)；反应偏向（c）= -0.5 × [z(Hit Rate) + z(FAR)]。`;
    const algoEn = `Algorithm: The false alarm rate (FAR) is the proportion of noise trials in which the participant reports hearing Chinese speech. The hit rate is the proportion of speech trials in which the participant reports hearing Chinese speech. To avoid infinite z-scores when a rate equals 0 or 1, a 0.5/N correction is applied before computing z-scores. Sensitivity (d') = z(Hit Rate) - z(FAR). Response bias (c) = -0.5 × [z(Hit Rate) + z(FAR)].`;
    algorithmDescription.innerText = algoZh + '\n\n' + algoEn;
}

// Inverse normal CDF (quantile) using Peter John Acklam's algorithm
// Source: Peter John Acklam (http://home.online.no/~pjacklam/notes/invnorm/)
function normInv(p, mean, std) {
    if (p <= 0 || p >= 1) {
        // handle edge cases separately
        if (p === 0) return -Infinity;
        if (p === 1) return Infinity;
        return NaN;
    }
    // Coefficients in rational approximations
    const a1 = -39.69683028665376;
    const a2 = 220.9460984245205;
    const a3 = -275.9285104469687;
    const a4 = 138.3577518672690;
    const a5 = -30.66479806614716;
    const a6 = 2.506628277459239;
    const b1 = -54.47609879822406;
    const b2 = 161.5858368580409;
    const b3 = -155.6989798598866;
    const b4 = 66.80131188771972;
    const b5 = -13.28068155288572;
    const c1 = -0.007784894002430293;
    const c2 = -0.3223964580411365;
    const c3 = -2.400758277161838;
    const c4 = -2.549732539343734;
    const c5 = 4.374664141464968;
    const c6 = 2.938163982698783;
    const d1 = 0.007784695709041462;
    const d2 = 0.3224671290700398;
    const d3 = 2.445134137142996;
    const d4 = 3.754408661907416;
    // Define break-points
    const plow = 0.02425;
    const phigh = 1 - plow;
    let q, r;
    let result;
    if (p < plow) {
        // Rational approximation for lower region
        q = Math.sqrt(-2 * Math.log(p));
        result = ((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6;
        result /= (((d1 * q + d2) * q + d3) * q + d4) * q + 1;
    } else if (p > phigh) {
        // Rational approximation for upper region
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6);
        result /= (((d1 * q + d2) * q + d3) * q + d4) * q + 1;
    } else {
        // Rational approximation for central region
        q = p - 0.5;
        r = q * q;
        result = (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q;
        result /= (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
    }
    return mean + std * result;
}
</script>

</body>
</html>
